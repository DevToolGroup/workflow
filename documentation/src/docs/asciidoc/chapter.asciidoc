[工作流组件]
= 工作流组件

[[背景]]
== 背景
在日常的工作中，工作流引擎在以下多种业务场景下发挥着关键作用，例如：

* 审批流程：文件、合同、报销单、请假申请等需要经过多级审批的场景
* 业务流程管理：采购到付款流程、销售订单处理、供应链管理等整合和自动化跨部门的业务流程
* 人力资源管理：请假申请，招聘流程、员工入职离职流程、培训安排、绩效考核等
* 文档管理：文档审批、版本控制、归档和检索流程。

以上场景的开源解决方案主要以BPMN 2.0为基础的开源流程引擎为主，包括Activiti，Flowable，Camunda，其中Flowable，Camunda又是基于Activiti的分支开发的。

在实际的落地过程中，尤其是包含网关、并行网关的Fork/Join概念对于企业用户来说理解配置比较复杂，需要重点的培训使用时的注意事项。 例如： 分叉节点与聚合节点最好是成对存在，方便理解，但是也不是绝对的；并行分支节点最好不要流转至Fork节点之前的其他节点，设计没有问题，但是运行时逻辑不清晰等。

基于以上原因，开发设计了 workflow 工作流组件，一方面简化了部分节点类型，当然节点类型可扩展，另一方面简化了网关的设计，降低理解难度，简化配置。

[[功能特点]]
== 功能特点
workflow是一个基于Java语言开发的流程引擎，其中：

* 数据存储采用Mybatis ORM
* 流程流转条件采用Spring El表达式
* 异步任务基于Java并发线程库的ThreadPoolExecutor
* 节点类型支持用户节点，事件节点，任务节点，延时任务节点，子流程节点
* 流程事件支持流程启动事件，节点创建事件，节点完成事件，流程或子流程结束事件，流程停止事件，流程异常事件
* 网关删除了排他，包含，并行网关，通过节点间连线实现排他的能力，通过条件子流程实现包含，并行网关
* 流程变量支持全局变量

[[快速开始]]
== 快速开始
[[环境准备]]
=== 环境准备
* Java版本： JDK 8
* http://maven.apache.org/[Apache Maven]

[[依赖配置]]
=== 依赖配置
当前项目版本为1.0-SNAPSHOT，使用前需clone代码上传至私有代码仓库。
后续在项目的 *pom.xml* 文件中增加以下maven配置。
[source, XML]
----
<dependencies>
  <dependency>
    <groupId>group.devtool.workflow.impl</groupId>
    <artifactId>impl</artifactId>
    <version>1.0-SNAPSHOT</version>
  </dependency>
</dependencies>
----
[[框架设计]]
[[架构总览]]
== 架构总览
[[流程建模]]
=== 流程建模

[[流程定义]]
==== 流程定义
流程定义主要用来描述流程的基本信息，流程节点定义，以及流程节点间连线定义，帮助流程引擎启动流程实例。
流程定义 `WorkFlowDefinition` 主要包括流程的编码，名称等，
流程节点定义 `WorkFlowNodeDefinition` 主要包括节点的编码，名称，类型以及相关配置，用于后续流程节点实例的初始化。
流程连线定义 `WorkFlowLinkDefinition` 主要包括连线的编码，起始节点，结束节点，以及条件表达式，条件解析器等配置。

[[流程实例]]
==== 流程实例
流程实例 `WorkFlowInstance` 主要描述运行态下，流程的整体状态，整个流程的状态流转以流程任务状态驱动，进而影响节点的状态，最后根据节点是否为结束节点判断流程实例是否结束。
流程节点实例 `WorkFlowNode` 主要根据节点配置完成流程任务的初始化。
流程任务实例 `WorkFlowTask` 作为整个流程引擎的基础，其状态直接影响到节点的状态。

[[流程引擎]]
==== 流程引擎
流程引擎 `WorkFlowEngine` 主要驱动节点的流转以及生命周期回调。

[[流程流转]]
==== 流程流转
在workflow中，只允许存在一个开始节点，结束节点，另外节点流转方向直接根据节点间连线的条件判断，没有引入网关（排他，包含，并行）的概念。

排他，包含，并行网关场景，通过以下方式实现：

* 排他场景，通过约束两个节点之间只允许存在一条满足条件的连接线，当存在多条连接线满足条件时，直接抛出异常。
* 包含/并行场景，通过并行的条件子流程实现，即在子流程的基础上，支持定义多个不同的子流程，每个子流程根据配置条件选择是否启动。

之所以不采用网关的概念，主要基于以下几点考虑：

* 包含/并行网关，在长事务中并发操作时需要加锁（悲观/乐观）保证流程正常往下流转，如果不考虑外部锁（Redis锁），那么只能在流程实例的维度加锁，在流程实例加锁影响整体的并发性能，如果缩小加锁范围，可行的方案是在网关派生子流程实例，那么增加了一定的复杂度。
* 在流程流转至包含网关汇聚节点时，由于无法直接计算汇聚节点的通过条件，需要遍历流程图，判断可达分支上是否还有活跃的节点，如果有则继续等待，直到所有活跃的分支节点到达汇聚节点，汇聚节点才继续往下流转，直观上，整体的性能不一定好。
* 包含/并行网关，在部分分支往回流转，其他分支不受影响，整体流转逻辑不易理解，因此，在实践时往往要求分支上的节点不允许往回流转、要求网关对等出现等以降低理解的难度，同时在程序上又无法限制。

基于以上三点原因，舍弃了网关的概念，通过条件子流程，将并行分支约束在子流程内部，约束往回流转的情况，另外，因为子流程的原因，包含网关不再需要遍历流程图即可实现是否继续流转的判断，一定程度上提高了性能。

关于包含/并行网关的加锁实现原理说明：
由于没有采用BPMN的包含，并行网关设计，而是采用条件子流程的方式，因此，在并发操作下，通过锁定条件子流程节点的版本，实现并发情况下的乐观锁效果。

[[任务异常]]
==== 任务异常
正常流转的情况下，流程引擎逻辑上不会出现异常，但是作为任务节点可能因为外部的原因导致异常，在workflow中没有异常边界的定义，而是希望在任务异常时通过异常变量使流程流转至对应的异常分支进行处理，以减少不必要的概念。

[[节点扩展]]
==== 节点扩展
当前节点类型仅支持：用户节点、任务节点、事件节点、延时任务节点、条件子流程节点，基本能够满足大部分场景需求，如果有特别的需求，可以实现 `WorkFlowNodeDefinition`接口完成节点的定义， 继承 `AbstractWorkFlowNode` 类完成节点的初始化以及相关任务的初始化。具体依赖注入可以参考当前的默认实现。

[[流程事务]]
== 流程事务
[[事务范围]]
=== 事务范围
流程引擎在启动或者任务触发时，将一直运行直到在每个活动执行路径上达到等待状态。等待状态是指稍后执行的任务，例如用户节点，事件节点，子流程节点等需要在满足条件/点击后才继续往下流转，这意味着引擎将当前执行持久化到数据库中，并等待再次触发。

[[并发乐观锁]]
=== 并发乐观锁
由于流程引擎采用长事务，因此并发操作时通过乐观锁保证并发的一致性。主要乐观锁场景包括：用户并发触发用户任务，因为事务隔离级别尤其可重复读的原因，导致并发的用户任务看不到彼此的任务状态，最终用户节点在任务都以完成的情况下无法继续流转；并行分支在并行完成时，与用户任务类似出现无法继续流转的情况，因此，需要通过乐观锁保证以上场景顺利进行。

[[数据存储]]
== 数据存储
默认的数据存储采用Mybatis ORM框架，支持根据自己的实际情况自定义实现，但在处理时需要注意以下几点：

*  流程实例的运行数据与历史数据未分开存储，而是计划采用分库分表的方式支持大规模的流程数据，因此，在流程运行相关的实例，节点，任务都提供了根流程实例ID字段，后续可根据该字段完成分库分表，例如Hash分表，一般云服务都支持。
*  采用分库分表的方案，可能还需要处理流程定义数据的跨库访问，可采用分布式缓存的方式，也可采用广播表的方式，具体根据实际情况选择。
*  采用分布式缓存方案存储流程定义时，需要注意缓存与数据库的数据一致性，当前流程部署是在一个大事务中，因此需要考虑额外实现事务服务 `WorkFlowTransaction` ，保证缓存数据的一致性

[[工作流集成]]
== 工作流集成
当前并没有采用开源方案中的表单设计器，主要以配合业务服务使用，因此，在集成使用的过程中，需要重点考虑以下内容：

1.  流程定义区分版本，保证正在运行的流程实例能够正常运行，因此，业务服务在调整时，尤其改动了流程定义时一定要注意在业务侧兼容不同版本的流程数据
2.  业务服务在集成时，需要考虑业务服务与流程服务之间的事务关系，尤其当流程服务作为微服务时，最好将流程的启动与操作放置在业务事务操作之后，当流程服务异常时，业务操作保持幂等，通过重试保证流程的顺利启动或操作
3.  在异步集成时，一般通过回调的流程上下文获取流程信息，但是，需要注意流程异常的情况，注意处理流程异常事件。

[[迭代计划]]
== 迭代计划
当前版本为1.0-SNAPSHOT，主体框架已完成，相关模型建模以及流程已跑通，后续迭代主要以完善功能点，增加服务编排为主。

主要迭代内容包括：

* 全局长事务改为短事务，其中需要重点处理服务器宕机，服务发版重启等异常情况下，短事务如何恢复，以及并发乐观锁异常的重试
* 当前流程流转采用递归的方式，在大规模的流程中，可能存在栈溢出的情况，后续改为迭代方式，另外需要考虑并结合第一点，实现短事务
* 回调的逻辑调整，结合第一，二两点改造回调，细化流程上下文的内容
* 异步化改造
* 设计界面的开发
